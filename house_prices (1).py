# -*- coding: utf-8 -*-
"""House Prices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QixjNyk-yYXY3I_PK-oG-8N3eCK7GUX3
"""

!wget 'https://storage.googleapis.com/kagglesdsdata/competitions/5407/868283/train.csv?GoogleAccessId=web-data@kaggle-161607.iam.gserviceaccount.com&Expires=1636219266&Signature=Oaq6mvRiPj%2B3AQXDVG8M5XNftIMxMWFkOBDc6XnOKuUNWs3%2F6%2BxvFwFEKeELfzYPRanLhGBSVJPr2LNmf0xCUMJNqlOjHXJrKlPwVbhqE9XoGkDfYyOdudd%2B5RWbecqKdxO8fQvGu5T4l1DCwToa%2FwGZyf5pijXZWcYY%2Bh5cpJp68iy6IZfKpw6PdfI6D9R%2BuS3uRITvtQK4jZCBmcySb9XJS%2B4FspzNMDSoHVEC%2Fj3PeIZU%2FKPlCvNYtPpOfMwrYBors6%2FiY4CnUCXK7LF%2FFtq8tYGkGS1z32BI%2FnD%2BhxDuts8ZSgcf%2FUCy%2Fbrph1wM1KClJziKrN0hthQM3tyd5g%3D%3D&response-content-disposition=attachment%3B+filename%3Dtrain.csv'

!wget 'https://storage.googleapis.com/kagglesdsdata/competitions/5407/868283/test.csv?GoogleAccessId=web-data@kaggle-161607.iam.gserviceaccount.com&Expires=1636219280&Signature=UPliBocxG4t38El107lxHppPN7oc6qqUKb%2BZQ2LJEDnlObg6Iu86KLhhZNdw6etIkzuC59e3g98n76lhDtgk72Czw8h1fgiYBVQcp4ipWNVj%2BmKuNccQzBUpf3gDPeFXu%2FSRpQlNDj5tBcwfK5fzJysEBRON7huo4tLC56hHyf9BqIXhgKgwxQk%2B2ls6xIJgtaii%2FgXbGZVEaDkG9xyneZfIN81CVQYOvc7a3PaBqS4XpK8ZRt%2FmpFCuGPwBNbnPGzraLHqZMNJrbfPyCsy8luV353evxvY8B4Z%2FWa7TNMLBilHWSuyHbKy9lsNQmntXeqH6mgYihaxaY5%2Bi94ZVBQ%3D%3D&response-content-disposition=attachment%3B+filename%3Dtest.csv'

!wget 'https://storage.googleapis.com/kagglesdsdata/competitions/5407/868283/sample_submission.csv?GoogleAccessId=web-data@kaggle-161607.iam.gserviceaccount.com&Expires=1636219288&Signature=TiexE0y%2B74Ml6401RuTcGlIvrIE%2Bm5QvJ%2BLZGsyduUGEGcq14UvV9TU5DuQU6tHlanlGcyZ1dfeSkyHtd%2F2ii5Q8cCFaPoXitRX1jUO3brq%2FCZ8bgSZ2e7tdOvDRzso6%2BI%2FvosL6MThgBkZIioxp7BbDkvfd3tdv4H93TTAmv0e4oSKkBFvygIYQIQRuOwt0xlN8%2FmbVvyhLkGBNv4VD211GaKfAjoy78mJSmgTsO6ilYbLhF1OHaFpyB4gj4NjYJ2aznkQxQ7fDKVbO1R7cdYZonAf9pwznCcp5w70rWrcWpyH8HBmRoYTooQQxidHU2ydxRKjLfZKr9X8oGP1Kmg%3D%3D&response-content-disposition=attachment%3B+filename%3Dsample_submission.csv'

!wget 'https://storage.googleapis.com/kagglesdsdata/competitions/5407/868283/data_description.txt?GoogleAccessId=web-data@kaggle-161607.iam.gserviceaccount.com&Expires=1636219296&Signature=Et3EerPYdjpybfM49H6RsUfjaJKinexeNpITRTbRfkSJim6y%2F097tT%2Fc3HKco6%2FZ6KrFVe9%2BxsfndHgRCC7Gchi6ZyFkdrNg9v5Er6D5kNQBXps7tWvZaykbHktZuyPPzrqV0mBm4dR%2FARozpZ9jXo2Bxa9Zk7D2DeUEp19Vw%2BF1qL0qtRRJfbAa1rlDgciWtpNmPzBdX5ndW3ehjCRffD1CQQvPF26Ss24IXEW5K5Hdnfg%2BOr0VySCX8oZu9seZQ%2B20DzJGQw5LQji99iGscQbXaNTfBq9KugkxNNNs6pNhTR2gzZVY6j4Q2i3cw7HFm1O3u1lbvGC5CUMuuoZu1Q%3D%3D&response-content-disposition=attachment%3B+filename%3Ddata_description.txt'

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import norm
from sklearn.preprocessing import StandardScaler
from scipy import stats
import warnings
warnings.filterwarnings('ignore')
# %matplotlib inline

data_train = pd.read_csv('train.csv')
data_test = pd.read_csv('test.csv')

df_train = data_train.copy()
df_test = data_test.copy()

print(df_train.columns)
print(df_train.shape)

df_train['SalePrice'].describe()

print(df_train.shape)
print(df_test.shape)

#skewness and kurtosis

print("Skewness :" , df_train['SalePrice'].skew())

print("Kurtosis :" , df_train['SalePrice'].kurt())

import missingno as mis
mis.matrix(df_train)

(df_train.isna().sum()/df_train.shape[0]).sort_values(ascending = False).head(10)

df_train.drop(columns = ['PoolQC' , 'MiscFeature' , 'Alley'] , inplace = True)
df_test.drop(columns = ['PoolQC' , 'MiscFeature' , 'Alley'] , inplace =True)

df_train['SalePrice'].describe()

#histogram SalePrice

sns.distplot(df_train['SalePrice']);

df_train.dtypes.value_counts()

df_test.dtypes.value_counts()

for col in df_test.select_dtypes('float64'):
    plt.figure()
    sns.distplot(df_train[col] , label = 'train')
    sns.distplot(df_test[col] , label = 'test')
    plt.legend()

for col in df_test.select_dtypes('int64'):
  plt.figure()
  sns.distplot(df_train[col] , label = 'train')
  sns.distplot(df_test[col] , label = 'test')
  plt.legend()

"""Relationship with numerical variables"""

for col in df_test.select_dtypes('int64'):
  plt.figure()
  plt.scatter(x=df_train[col] , y = df_train['SalePrice'])

for col in df_train.select_dtypes('object'):
  plt.subplots(figsize = (8 , 6))
  sns.boxplot(df_train[col] , df_train['SalePrice'])

#correlation matrix
corrmat = df_train.corr()
f, ax = plt.subplots(figsize=(12, 9))
sns.heatmap(corrmat, vmax=.8, square=True);

#saleprice correlation matrix
k = 10
cols = corrmat.nlargest(k, 'SalePrice')['SalePrice'].index
cm = np.corrcoef(df_train[cols].values.T)
sns.set(font_scale=1.25)
hm = sns.heatmap(cm, cbar=True, annot=True, square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols.values, xticklabels=cols.values)
plt.show()

sns.distplot(df_train['SalePrice'] , fit=norm);

# Get the fitted parameters used by the function
(mu, sigma) = norm.fit(df_train['SalePrice'])

#Now plot the distribution
plt.legend(['Normal dist. ($\mu=$ {:.2f} and $\sigma=$ {:.2f} )'.format(mu, sigma)],
            loc='best')
plt.ylabel('Frequency')
plt.title('SalePrice distribution')

#Get also the QQ-plot
fig = plt.figure()
res = stats.probplot(df_train['SalePrice'], plot=plt)
plt.show()

#We use the numpy fuction log1p which  applies log(1+x) to all elements of the column
df_train["SalePrice"] = np.log1p(df_train["SalePrice"])

#Check the new distribution 
sns.distplot(df_train['SalePrice'] , fit=norm);

# Get the fitted parameters used by the function
(mu, sigma) = norm.fit(df_train['SalePrice'])

#Now plot the distribution
plt.legend(['Normal dist. ($\mu=$ {:.2f} and $\sigma=$ {:.2f} )'.format(mu, sigma)],
            loc='best')
plt.ylabel('Frequency')
plt.title('SalePrice distribution')

#Get also the QQ-plot
fig = plt.figure()
res = stats.probplot(df_train['SalePrice'], plot=plt)
plt.show()

"""Features engineering"""

n_train = df_train.shape[0]
n_test = df_test.shape[0]

y_train = df_train.SalePrice.values

all_data = pd.concat((df_train , df_test)).reset_index(drop =True)
all_data.drop(['SalePrice'] , axis = 1 , inplace = True)

print("all data size  is : {}".format(all_data.shape))

all_data_na = (all_data.isnull().sum() / len(all_data)) * 100

all_data_na = all_data_na.drop(all_data_na[all_data_na == 0].index).sort_values(ascending=False)[:30]

f , ax = plt.subplots(figsize = (15 , 12))
plt.xticks(rotation = '90')
sns.barplot(x = all_data_na.index , y = all_data_na)
plt.xlabel('Features', fontsize = 15)
plt.ylabel('percent of missing valuues' , fontsize = 15)
plt.title('Percent missing data by feature', fontsize=15)

all_data['Fence'] = all_data['Fence'].fillna("None")

all_data['FireplaceQu'] = all_data['FireplaceQu'].fillna("None")

#Group by neighborhood and fill in missing value by the median LotFrontage of all the neighborhood

all_data['LotFrontage'] = all_data.groupby("Neighborhood")['LotFrontage'].transform(lambda x:x.fillna(x.median()))

for col in ('GarageType', 'GarageFinish', 'GarageQual', 'GarageCond'):
    all_data[col] = all_data[col].fillna('None')

for col in ('GarageYrBlt', 'GarageArea', 'GarageCars'):
  all_data[col] = all_data[col].fillna(0)

for col in ('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2'):
    all_data[col] = all_data[col].fillna('None')

all_data["MasVnrType"] = all_data["MasVnrType"].fillna("None")
all_data["MasVnrArea"] = all_data["MasVnrArea"].fillna(0)

all_data['MSZoning'] = all_data['MSZoning'].fillna(all_data['MSZoning'].mode()[0])

"""Utilities : For this categorical feature all records are "AllPub", except for one "NoSeWa" and 2 NA . Since the house with 'NoSewa' is in the training set."""

all_data = all_data.drop(['Utilities'], axis=1)

all_data["Functional"] = all_data["Functional"].fillna("Typ")

all_data['Electrical'] = all_data['Electrical'].fillna(all_data['Electrical'].mode()[0])

all_data['KitchenQual'] = all_data['KitchenQual'].fillna(all_data['KitchenQual'].mode()[0])

all_data['Exterior1st'] = all_data['Exterior1st'].fillna(all_data['Exterior1st'].mode()[0])
all_data['Exterior2nd'] = all_data['Exterior2nd'].fillna(all_data['Exterior2nd'].mode()[0])

all_data['SaleType'] = all_data['SaleType'].fillna(all_data['SaleType'].mode()[0])

all_data['MSSubClass'] = all_data['MSSubClass'].fillna("None")

all_data_na = (all_data.isnull().sum() / len(all_data)) * 100

all_data_na = all_data_na.drop(all_data_na[all_data_na == 0].index).sort_values(ascending = False)

#transforming some numerical variables that are really categorical

all_data['MSSubClass'] = all_data['MSSubClass'].apply(str)

#Changing OverallCond into a categorical variable

all_data['OverallCond'] = all_data['OverallCond'].astype(str)

all_data['YrSold'] = all_data['YrSold'].astype(str)

all_data['MoSold'] = all_data['MoSold'].astype(str)

all_data.columns

"""Label Encoding

"""

from sklearn.preprocessing import LabelEncoder
cols = ('FireplaceQu', 'BsmtQual', 'BsmtCond', 'GarageQual', 'GarageCond', 
        'ExterQual', 'ExterCond','HeatingQC', 'KitchenQual', 'BsmtFinType1', 
        'BsmtFinType2', 'Functional', 'Fence', 'BsmtExposure', 'GarageFinish', 'LandSlope',
        'LotShape', 'PavedDrive', 'Street', 'CentralAir', 'MSSubClass', 'OverallCond', 
        'YrSold', 'MoSold')

for c in cols:
  lbl = LabelEncoder()
  lbl.fit(list(all_data[c]))
  all_data[c] = lbl.transform(list(all_data[c].values))

print('Shape all_data : {}'.format(all_data.shape))

"""Since area related features are very important to determine house prices, we add one more feature which is the total area of basement, first and second floor areas of each house


"""

all_data['TotalSF'] = all_data['TotalBsmtSF'] + all_data['1stFlrSF'] + all_data['2ndFlrSF']

df_train = all_data[:n_train]
df_test = all_data[n_train:]

"""modeling """

from sklearn.linear_model import ElasticNet , Lasso , BayesianRidge , LassoLars
from sklearn.ensemble import RandomForestRegressor , GradientBoostingRegressor
from sklearn.kernel_ridge import KernelRidge
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import RobustScaler
from sklearn.base import BaseEstimator , TransformerMixin , RegressorMixin , clone 
from sklearn.model_selection import KFold , cross_val_score ,train_test_split
from sklearn.metrics import mean_squared_error
import xgboost as xgb
import lightgbm as lgb

